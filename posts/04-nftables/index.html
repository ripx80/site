<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=author content="ripx80"><title>nftables - basics | ripx80 onexec</title>
<link rel=stylesheet href=/css/main.min.70f74d6cc30185fa0ce09360143563220b745deaa17fef658bdb181aea5a5c7d.css integrity="sha256-cPdNbMMBhfoM4JNgFDVjIgt0Xeqhf+9li9sYGupaXH0=" crossorigin=anonymous></head><body><header><a class=mainlink href=/><div class=logo></div><h1>ripx80 onexec</h1></a><nav class=nav><ul><li><a href=/>home</a></li><li><a href=/posts/>blog</a></li><li><a href=/lib>lib</a></li><li><a href=/tags>tags</a></li><li><a href=/whoami>whoami</a></li></ul></nav><section id=about>ripx80&rsquo;s technical thoughts and efforts to remember yesterday</section></header><main><h1 class=blogtitle>nftables - basics</h1><div class=meta><time datetime=2024-04-15T00:00:00+00:00>2024-04-15</time>
<time datetime=2025-02-17T14:28:34+01:00>| 2025-02-17</time>
<span>| 2680</span></div><h2>short</h2><article><p>update: <strong>2024-04-20</strong></p><p>nftables is the modern linux kernel (>= 3.13 nft <a href="https://git.netfilter.org/nftables/log/doc?showmsg=1">support</a>) packet classification framework to replace iptables.</p><p>iptables is not covered in this essay.</p><p>you need such packet filters in firewalls and routers to accept, drop or forward network packets.
this post will deal the basics of nftables and show some commands/rules to handle rules and configure this rules in your linux system.
in particular, a nixos system and its configuration are discussed but these rules apply to most systems with nftables.</p><p>if you search for a advanced topic and how i configure a real world router i recommend the <strong>nftables advanced router</strong> (comming soon) post.
do you need further use cases or fresh ideas? take a look at <strong>50 things - nftables</strong> (comming soon) post.</p><ul><li>system: x86_64</li><li>kernel: 6.7.9</li><li>nixos: 23.11</li><li>nftables: 1.0.9</li><li>libressl-3.8.2-nc (netcat)</li></ul><p>nixos modules:</p><ul><li><a href=https://github.com/nixos/nixpkgs/blob/nixos-23.11/nixos/modules/services/networking/firewall.nix>firewall</a></li><li><a href=https://github.com/nixos/nixpkgs/blob/nixos-23.11/nixos/modules/services/networking/firewall-nftables.nix>firewall-nftables</a></li><li><a href=https://github.com/nixos/nixpkgs/blob/nixos-23.11/nixos/modules/services/networking/nftables.nix>nftables</a></li></ul><h2 id=netfilter>netfilter</h2><p>netfilter is the underlying framework in the linux kernel on which nftables is based.</p><p>&ldquo;the netfilter project enables packet filtering, network address [and port] translation, packet logging, userspace packet queueing and other packet mangling.</p><p>the netfilter hooks are a framework inside the linux kernel that allows kernel modules to register callback functions at different locations of the linux network stack. the registered callback function is then called back for every packet that traverses the respective hook within the linux network stack.&rdquo; - netfilter.org</p><p>this is the current statement of the netfilter project what netfilter is.
in this case we only know, that netfilter is the linux framework for manipulating network packets. it can filter and transform packets at predefined points in the kernel.</p><p>nftables sits on top of this framework.</p><h2 id=nft>nft</h2><p>nft is the shell command to manipulate the packet filter inside the kernel.
nft can be used to list, manipulate and debug rules.</p><div class=speechbubble><div class=garry><img src=https://ripx80.de/img/garry-64.webp alt=garry></div><div class=chat><p><span class=whisper></span>
note that the position of the statements within your rule is significant, because nftables evaluates expressions and statements linearly from left to right.</p></div></div><p>here are some commands to interact with the packet framework.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># show</span>
</span></span><span style=display:flex><span><span style=color:#75715e># list current tables</span>
</span></span><span style=display:flex><span>nft list tables
</span></span><span style=display:flex><span><span style=color:#75715e># list all named counters</span>
</span></span><span style=display:flex><span>nft list counters
</span></span><span style=display:flex><span><span style=color:#75715e># list table filter, omit stateful information like counters</span>
</span></span><span style=display:flex><span>nft --stateless list table filter
</span></span><span style=display:flex><span><span style=color:#75715e># list all nft instructions</span>
</span></span><span style=display:flex><span>nft -s list ruleset
</span></span><span style=display:flex><span><span style=color:#75715e># list all chains with handle (need to delete)</span>
</span></span><span style=display:flex><span>nft -a list chains
</span></span><span style=display:flex><span><span style=color:#75715e># output the complete ruleset in json format, export</span>
</span></span><span style=display:flex><span>nft -j list ruleset
</span></span><span style=display:flex><span><span style=color:#75715e># get the handle to delte a rule</span>
</span></span><span style=display:flex><span>nft list ruleset -a
</span></span><span style=display:flex><span><span style=color:#75715e># see live changes on ruleset</span>
</span></span><span style=display:flex><span>nft monitor
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># manipulate</span>
</span></span><span style=display:flex><span><span style=color:#75715e># delete rule in nixos-fw chain input-allow handle 17</span>
</span></span><span style=display:flex><span>nft delete rule inet nixos-fw input-allow handle <span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span><span style=color:#75715e># add chain prerouting with default policy drop</span>
</span></span><span style=display:flex><span>nft add ip chain nat prerouting <span style=color:#e6db74>&#39;{ policy drop; }&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># add chain nat postrouting with default policy accept</span>
</span></span><span style=display:flex><span>nft add chain ip nat postrouting <span style=color:#e6db74>&#39;{ policy accept; }&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># replace a current rule with a new one</span>
</span></span><span style=display:flex><span>nft replace rule inet forward handle <span style=color:#ae81ff>5</span> iif <span style=color:#e6db74>&#34;et0&#34;</span> oif <span style=color:#e6db74>&#34;eth1&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>counter accept
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># clear</span>
</span></span><span style=display:flex><span><span style=color:#75715e># flush only table ip filter</span>
</span></span><span style=display:flex><span>nft flush table ip filter
</span></span><span style=display:flex><span><span style=color:#75715e># flush all rules</span>
</span></span><span style=display:flex><span>nft flush ruleset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># test</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  read the nft file (f), optimize ruleset(o) in dry-run mode (c)</span>
</span></span><span style=display:flex><span>nft -c -o -f ruleset.test
</span></span></code></pre></div><p>further commands can be found in the official <a href=https://wiki.nftables.org/wiki-nftables/index.php/quick_reference-nftables_in_10_minutes>nftables wiki</a>.</p><p>if the ruleset should to be testet for syntactical erros it is a good idea to use the dry-run or check feature.
no rules are applied to the running system.</p><h2 id=families>families</h2><p>nftables has different family types with which you can interact. these families represent multiple networking levels.
if the different network layers are no longer present, it is advisable to look at the osi-model first.</p><ul><li>ip: only see ipv4 traffic</li><li>ip6: only see ipv6 traffic</li><li>inet: tables of this family see both ipv4 and ipv6 traffic/packets, simplifying dual stack support.</li><li>arp: arp level traffic</li><li>bridge: traffic/packets traversing bridges</li><li>netdev: the netdev family is different from the others in that it is used to create base chains attached to a single network interface like &ldquo;eth0&rdquo;.
such base chains see all network traffic on the specified interface, with no assumptions about layer 2 or layer 3 protocols.</li></ul><p>for example if you want to create a rule to filter a packet for ipv4 and ipv6 you can use &ldquo;inet&rdquo; to handle both protocols in one rule.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>add rule inet filter input udp dport <span style=color:#ae81ff>53</span> accept
</span></span></code></pre></div><p>this rule is applied to ipv4 <strong>and</strong> ipv6 and allows packets based on the udp protocol with destination port 53 (usually dns) to pass the filter.
but you can also set the ip protocol in the inet family.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># use ip or ipv6 to define the protocol version</span>
</span></span><span style=display:flex><span>add rule inet filter input ip udp dport <span style=color:#ae81ff>53</span> accept
</span></span></code></pre></div><p>with the &ldquo;ip&rdquo; keyword this rule is only applied to ipv4 packets not for ipv6.</p><h2 id=basic-structures>basic structures</h2><h3 id=table>table</h3><p>a table is top structure to contain multiple chains.
each table has a family type and name. the default type is <strong>ip</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># diplay tables</span>
</span></span><span style=display:flex><span>nft list tables
</span></span></code></pre></div><h3 id=chain>chain</h3><p>a chain is located inside a table and has a specific <strong>type</strong> like filter, route, nat.
in addition a chain has a speical <strong>hook</strong> that indicates the stage in which the packet is precoessed in the kernel
like prerouting, input, forward, output and postrouting.</p><p>note that some types and hooks are only available for certain families.</p><p>each chain has a <strong>priority</strong> that refers to a number used to order the chains or to set them between some netfilter operations.
when you set a priority (default is 0) you can use the number or the defined constant.</p><ul><li>NF_IP_PRI_CONNTRACK_DEFRAG (-400)</li><li>NF_IP_PRI_RAW (-300)</li><li>NF_IP_PRI_SELINUX_FIRST (-225)</li><li>NF_IP_PRI_CONNTRACK (-200)</li><li>NF_IP_PRI_MANGLE (-150)</li><li>NF_IP_PRI_NAT_DST (-100)</li><li>NF_IP_PRI_FILTER (0) - default</li><li>NF_IP_PRI_SECURITY (50)</li><li>NF_IP_PRI_NAT_SRC (100)</li><li>NF_IP_PRI_SELINUX_LAST (225)</li><li>NF_IP_PRI_CONNTRACK_HELPER (300)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nft add chain inet mytable mychain <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>&#39;{ type filter hook input priority -10; }&#39;</span>
</span></span></code></pre></div><p>this command creates a chain <strong>&lsquo;mychain&rsquo;</strong> in table <strong>&lsquo;mytable&rsquo;</strong> with a priority of <strong>&rsquo;-10&rsquo;</strong> for the <strong>&lsquo;input&rsquo;</strong> hook.
a lower number indicates a higher priority, so this chain would process packets before the default input chain (priority 0).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># display chains</span>
</span></span><span style=display:flex><span>nft list chains
</span></span></code></pre></div><h3 id=rule>rule</h3><p>an rule is a specific instruction that defines how packets should processed within a tabel&rsquo;s chain.
it represents a single action or a set of conditions applied to a packet.</p><p>a <strong>match</strong> is a condition that determine whether a rule applies to a packet. matches can include protocols (tcp, udp, icmp),
packet metadata, connection tracking states and custom defined data or payload inspections.</p><p>a <strong>action</strong> can defined when a rule match like accept, drop, reject, log, queue or continue.</p><p>each rule has its own handle (numeric reference), which identifies the rule within the chain in which it is located.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nft -a list chain inet fw services
</span></span></code></pre></div><p>this command displays all rules with handle in chain <strong>&lsquo;services&rsquo;</strong> and table <strong>&lsquo;fw&rsquo;</strong>.</p><h2 id=nft-monitor>nft monitor</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nft monitor
</span></span></code></pre></div><p>allows you to observe or track live changes to the ruleset.
nft monitor is informed via kernel events thats a change has been made to the current ruleset.
only then is something output.</p><p>for example start nft monitor and then add a rule to your ruleset.
two different shells are needed, one to monitor the event and one to apply the rule.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># 1. shell, this will catch the prompt</span>
</span></span><span style=display:flex><span>nft monitor
</span></span><span style=display:flex><span><span style=color:#75715e># 2. shell</span>
</span></span><span style=display:flex><span>nft add rule inet fw services iif <span style=color:#e6db74>&#34;eth0&#34;</span> tcp dport <span style=color:#ae81ff>443</span> accept
</span></span><span style=display:flex><span>nft -a list chain services
</span></span></code></pre></div><p>this rule will open ipv4 and ipv6 tcp port 443 (usaly https) on interface &ldquo;eth0&rdquo;.
the rule will be stored in table &ldquo;fw&rdquo; and the chain &ldquo;services&rdquo;.</p><p>you will see in your monitor shell something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>add rule inet fw services iif <span style=color:#e6db74>&#34;eth0&#34;</span> tcp dport <span style=color:#ae81ff>443</span> accept
</span></span><span style=display:flex><span><span style=color:#75715e># new generation 3 by process 397259 (nft)</span>
</span></span></code></pre></div><p>you see the generation &ldquo;3&rdquo; of the ruleset. in addition the process (397259) and command (nft) that changed it.
then we delete the previously created rule again.
to delete a rule the internal handle of the respective rule is required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nft -a list chain inet fw services
</span></span><span style=display:flex><span><span style=color:#75715e># in my case, get the handle 19</span>
</span></span><span style=display:flex><span>nft delete rule inet fw services handle <span style=color:#ae81ff>19</span>
</span></span></code></pre></div><p>nft monitor is particularly helpful to debug processes that make independent changes to the ruleset.
for example, container orchestration or container runtime environments like kubernetes.</p><h2 id=nftrace>nftrace</h2><p>nftrace is the <a href=https://wiki.nftables.org/wiki-nftables/index.php/ruleset_debug/tracing>debug and tracing</a> tool for nftables which is since nftables version 0.6 and linux kernel 4.6 supported.
to use it, the packet to be tracked must be marked via the meta information of nftables.
to do this, we use the rule from above and set the meta information for this specific packet.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># enable tracing</span>
</span></span><span style=display:flex><span>nft add rule inet fw services iif <span style=color:#e6db74>&#34;eth0&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>tcp dport <span style=color:#ae81ff>443</span> meta nftrace set <span style=color:#ae81ff>1</span> accept
</span></span><span style=display:flex><span><span style=color:#75715e># start and waiting for events</span>
</span></span><span style=display:flex><span>nft monitor trace
</span></span></code></pre></div><p>tracing for https (usaly) was activated using the statement <strong>&lsquo;meta nftrace set 1&rsquo;</strong>
the tracing takes place via the <strong>&rsquo;nft monitor trace&rsquo;</strong> cmd.</p><p>to generate some traffic on port 443 and thus some events, i like to use netcat.
first we create a listener to connect to it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># listen only on eth0 port 443 tcp</span>
</span></span><span style=display:flex><span>nc -l 192.168.1.2 <span style=color:#ae81ff>443</span>
</span></span></code></pre></div><p>you have to make sure that it does not run via the internal loopback &rsquo;lo&rsquo; interface, as this is usually configured as trusted and always works in conjunction with nftables. In addition, the tracing rule would not work here.</p><p>that&rsquo;s why i connect from another maschine to the &rsquo;eth0&rsquo; interface with the ip &lsquo;192.168.1.2&rsquo; via netcat.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># connect to this port from a external maschine (192.168.100.3)</span>
</span></span><span style=display:flex><span>nc 192.168.1.2 <span style=color:#ae81ff>443</span>
</span></span></code></pre></div><p>after the successful connection, a event is displayed in <strong>nft monitor trace</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>trace id 5ac77d91 inet fw services packet: iif &#34;eth0&#34; ip saddr 192.168.1.3 ip daddr 192.168.1.2 ip dscp cs0 ip ecn not-ect ip ttl 64 ip id 1816 ip protocol tcp ip length 60 tcp sport 40776 tcp dport 443 tcp flags == syn tcp window 32160
</span></span><span style=display:flex><span>trace id 5ac77d91 inet fw services unknown rule handle 22 (verdict accept)
</span></span></code></pre></div><p>a lot of interesting information is displayed in this tracing event.</p><ul><li>5ac77d91: trace id</li><li>inet: family</li><li>chain: services</li><li>eth0: interface</li><li>192.168.1.3: source addresse (connect from)</li><li>192.168.1.2: destination address (connect to)</li><li>40776: source port (connect from)</li><li>443: destination port (connect to)</li><li>22: exact handle of the rule that triggers the event</li></ul><p>and some debugging informations like ttl (64), tcp flags (syn) and window size (32160).</p><p>if you want to enable tracing for a complete chain or before the input rules are processed you can add a tracing chain.
the <a href="https://wiki.nftables.org/wiki-nftables/index.php/ruleset_debug/tracing#:~:text=same%20trace%20session.-,complete%20example,-here%20is%20complete">nftables wiki</a> has a good example of how you do this.</p><p>after debugging, the tracing rule should be deleted.</p><h2 id=nftables-with-nixos>nftables with nixos</h2><p>after the basic introduction to nftables, here is how to configure this in nixos.
nftables can be enabled with this nixos setting.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>network<span style=color:#f92672>.</span>nftables<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span></code></pre></div><p>this will add the <strong>pkgs.nftables</strong> to your system environment and create a default ruleset for your system.
you can display the default ruleset with the following command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ nft list ruleset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># default name nixos-fw, inet rules defined for ipv4 and ipv6 traffic</span>
</span></span><span style=display:flex><span>table inet nixos-fw <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># chain for reverse path filtering and dhcp</span>
</span></span><span style=display:flex><span>    chain rpfilter <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># this will change the priority of mangle to 10 and a default chain policy to drop</span>
</span></span><span style=display:flex><span>        type filter hook prerouting priority mangle + 10; policy drop;
</span></span><span style=display:flex><span>        <span style=color:#75715e># this will open dhcpv4 on port 68 and 67 bootp</span>
</span></span><span style=display:flex><span>        meta nfproto ipv4 udp sport . udp dport <span style=color:#f92672>{</span> <span style=color:#ae81ff>68</span> . 67, <span style=color:#ae81ff>67</span> . <span style=color:#ae81ff>68</span> <span style=color:#f92672>}</span> accept comment <span style=color:#e6db74>&#34;dhcpv4 client/server&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># check reverse path, see networking.firewall.checkReversePath</span>
</span></span><span style=display:flex><span>        fib saddr . mark . iif oif exists accept
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># default input chain</span>
</span></span><span style=display:flex><span>    chain input <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># filter with default drop policy</span>
</span></span><span style=display:flex><span>        type filter hook input priority filter; policy drop;
</span></span><span style=display:flex><span>        <span style=color:#75715e># lo is a trusted interface, see networking.firewall.trustedInterfaces</span>
</span></span><span style=display:flex><span>        iifname <span style=color:#e6db74>&#34;lo&#34;</span> accept comment <span style=color:#e6db74>&#34;trusted interfaces&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># track the state of the conntrack, new and untracked will handled in input-allow</span>
</span></span><span style=display:flex><span>        ct state vmap <span style=color:#f92672>{</span> invalid : drop, established : accept, related : accept, new : jump input-allow, untracked : jump input-allow <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># log invald syn tcp connections</span>
</span></span><span style=display:flex><span>        tcp flags syn / fin,syn,rst,ack log prefix <span style=color:#e6db74>&#34;refused connection: &#34;</span> level info
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    chain input-allow <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># allow ping requests</span>
</span></span><span style=display:flex><span>        icmp type echo-request accept comment <span style=color:#e6db74>&#34;allow ping&#34;</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e># allow dhcpv6</span>
</span></span><span style=display:flex><span>        icmpv6 type !<span style=color:#f92672>=</span> <span style=color:#f92672>{</span> nd-redirect, <span style=color:#ae81ff>139</span> <span style=color:#f92672>}</span> accept comment <span style=color:#e6db74>&#34;accept all icmpv6 messages except redirects and node information queries (type 139).  see rfc 4890, section 4.4.&#34;</span>
</span></span><span style=display:flex><span>        ip6 daddr fe80::/64 udp dport <span style=color:#ae81ff>546</span> accept comment <span style=color:#e6db74>&#34;dhcpv6 client&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># without any trusted ports defined in networking.firewall.allowedTcpPorts</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>this is the default ruleset for nixos when nftables is enabled and if no changes have been made.
you can see the function of each instruction in the comments or look into the official nixos modules.</p><p>It is interesting to note that dhcp cannot be blocked or switched off via the nixos module.
if no dhcp is required, this can only be circumvented by flashing the entire ruleset.</p><p>other interesting options of the nixos module <strong>network.firewall</strong> are:</p><ul><li>logReversePathDrops</li><li>logRefusedConnections</li><li>logRefusedPackets</li><li>logRefusedUnicastsOnly</li><li>rejectPackets</li><li>allowPing</li><li>pingLimit</li></ul><p>take a look at <a href="https://search.nixos.org/options?channel=23.11&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=firewall">nixos options</a> for a detailed explaination of each option.</p><p>on a normal system without advanced routing stuff or special security requirements is this my preferred configuration.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>networking <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  firewall <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e># disable logging of refuded connections</span>
</span></span><span style=display:flex><span>      logRefusedconnections <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e># disable logging of refused packages</span>
</span></span><span style=display:flex><span>      logRefusedPackets <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e># allow ping for diagnostics</span>
</span></span><span style=display:flex><span>      allowPing <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e># allow wireguard connections from the internet</span>
</span></span><span style=display:flex><span>      interfaces<span style=color:#f92672>.</span>eth0 <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        allowedUdpPorts <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>            meta<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>config<span style=color:#f92672>.</span>networking<span style=color:#f92672>.</span>hostname<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>wg<span style=color:#f92672>.</span>port
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># internal wireguard services</span>
</span></span><span style=display:flex><span>      interfaces<span style=color:#f92672>.</span>wg0 <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e># allow internal ssh and dns via tcp connections</span>
</span></span><span style=display:flex><span>        allowedTcpPorts <span style=color:#f92672>=</span> [ <span style=color:#ae81ff>22</span> <span style=color:#ae81ff>53</span> ];
</span></span><span style=display:flex><span>        <span style=color:#75715e># allow internal dns via upd (default for dns queries)</span>
</span></span><span style=display:flex><span>        allowedUdpPorts <span style=color:#f92672>=</span> [ <span style=color:#ae81ff>53</span> ];
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>this config allows only wireguard connections to a open port to the internet.
internal services like ssh and dns connections are accessable via the internal wireguard network.
this will protect the system for unallowed ssh connection attemps from outside and reduce the attack vector.</p><p>log for refuded connections and packets are disabled because i dont need it.</p><div class=speechbubble><div class=garry><img src=https://ripx80.de/img/garry-64.webp alt=garry></div><div class=chat><p><span class=whisper></span>
meta.nix is a git-encrypt file which contains ip addresses, port numbers and other stuff that are not to be landed in git's cleartext history. it is imported and the individual fields are accessed via the hostname like you see above. normaly you will add here your wireguard port number as integer</p></div></div><p>when you build the configuration via <strong>&rsquo;nixos-rebuild build &ndash;flake .#mysystem&rsquo;</strong> the path to the evaluated ruleset can be found in the systemd file &lsquo;result/etc/systemd/system/nftables.service&rsquo;. Search for the line beginning with ExecStart to identify the nix store path of nftables-rules.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span># example path on mysystem, on other systems it has a different path
</span></span><span style=display:flex><span>ExecStart=/nix/store/ngdbcld1pdh1h8zpn1541c35zv25q6r2-nftables-rules
</span></span></code></pre></div><p>in this exanple the file &lsquo;/nix/store/ngdbcld1pdh1h8zpn1541c35zv25q6r2-nftables-rules&rsquo; contains the subsequent rules that will be applied to the system.</p><h2 id=conclusion>conclusion</h2><p>now i have the basics that i need to setup a simple packet filter on my nixos hosts and debug the current rule set.
i can only recommend looking into the sources given to familiarize yourself with the whole topic.</p><p>time to get hands dirty for the real project of this journey: the nixos wireguard <a href=https://ripx80.de/posts/04-nftables/>nftables-router</a> with vpn support.</p><h2 id=docs>docs</h2><ul><li><a href=https://wiki.nftables.org/wiki-nftables/index.php/main_page>wiki</a></li><li><a href=https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks>netfilter hooks</a></li><li><a href="https://git.netfilter.org/nftables/log/doc?showmsg=1">timeline log</a> of nft development</li><li><a href=https://wiki.nftables.org/wiki-nftables/index.php/quick_reference-nftables_in_10_minutes>nft in 10 minutes</a></li><li><a href=https://scvalex.net/posts/54/>nftables on nixos</a></li><li><a href=https://wiki.nftables.org/wiki-nftables/index.php/flowtables>flowtables</a></li><li><a href=https://docs.kernel.org/networking/nf_flowtable.html>flowtables kernel</a></li><li><a href="https://thermalcircle.de/doku.php?id=blog:linux:flowtables_1_a_netfilter_nftables_fastpath">deep explaination of flowtables</a></li><li><a href=https://francis.begyn.be/blog/nixos-home-router>nixos-home-router</a></li><li><a href=https://pavluk.org/blog/2022/01/26/nixos_router.html>nixos-router</a></li><li><a href=https://www.procustodibus.com/blog/2021/11/wireguard-nftables/>wireguard nftables</a></li></ul><h2 id=learned>learned</h2><ul><li><a href=https://www.kernel.org/doc/documentation/networking/ip-sysctl.txt>difference</a> between net.ipv4.conf.all.forwarding and net.ipv4.ip_forward.</li><li>sysctl &ndash;system shows all system settings without a config file</li><li>ip mangle table: it is basically used to set specific headers for ip packets to affect the routing decision made further on. like mtu or ttl.</li><li>nixos opens automaticly dhcp ipv4 and ipv6 ports when networking.firewall.enable = true.</li><li>nixos networking.firewall.checkReversePath is default true</li><li>libressl-3.8.2-nc is a dependency of libressl-3.8.2 which is part of gibc of all nixos systems, so nc is available on default
nix-store &ndash;tree &ndash;query /nix/store/kvkiy1i5d1mh4q3rylsy4qshsrgsimaa-libressl-3.8.2-nc</li><li>refreshing netcat commands</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nc host port <span style=color:#f92672>(</span>tcp connection<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>nc -u host port <span style=color:#f92672>(</span>udp connection<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>nc -z -v domain.com 1-1000 <span style=color:#75715e># port scanning</span>
</span></span><span style=display:flex><span>nc -l <span style=color:#ae81ff>4444</span> <span style=color:#75715e># listen</span>
</span></span><span style=display:flex><span>nc -l <span style=color:#ae81ff>4444</span> &gt; received_file <span style=color:#75715e># files through</span>
</span></span><span style=display:flex><span>nc domain.com <span style=color:#ae81ff>4444</span> &lt; original_file
</span></span><span style=display:flex><span><span style=color:#75715e># http://server_ip:8888</span>
</span></span><span style=display:flex><span>nc <span style=color:#e6db74>&#39;http/1.1 200 ok\n\n%s&#39;</span> <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>cat index.html<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> | netcat -l <span style=color:#ae81ff>8888</span>
</span></span></code></pre></div></article><div><div>tags:
[<a href=/tags/network/>network</a>]
[<a href=/tags/security/>security</a>]
[<a href=/tags/nix/>nix</a>]</main><footer></footer></body></html>